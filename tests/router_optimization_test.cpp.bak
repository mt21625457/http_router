/**
 * @file router_optimization_test.cpp
 * @author mt21625457 (mt21625457@163.com)
 * @brief 路由器优化功能的详细单元测试 - Detailed unit tests for router optimization features
 * @version 0.2
 * @date 2025-03-26
 *
 * @copyright Copyright (c) 2025
 *
 * 本文件包含对router.hpp中集成的优化功能的全面测试
 * This file contains comprehensive tests for optimization features integrated in router.hpp
 *
 * 测试覆盖范围 Test Coverage:
 * 1. split_path_optimized() 函数测试
 * 2. url_decode_safe() 函数测试
 * 3. hex_to_int_safe() 函数测试
 * 4. cache_key_builder 类测试
 * 5. 性能基准测试
 * 6. 边界条件和错误处理测试
 * 7. 内存安全测试
 * 8. 线程安全测试
 */

#include <algorithm>
#include <chrono>
#include <gtest/gtest.h>
#include <random>
#include <thread>
#include <vector>

#include "router/router.hpp"

using namespace flc;

/**
 * @brief 测试用的简单处理器类 - Simple handler class for testing
 */
class TestHandler
{
private:
    int id_;

public:
    explicit TestHandler(int id) : id_(id) {}
    int id() const { return id_; }
    void handle() const {}
};

/**
 * @class RouterOptimizationTest
 * @brief 路由器优化功能测试套件 - Router optimization test suite
 */
class RouterOptimizationTest : public ::testing::Test
{
protected:
    // 使用智能指针延迟构造，避免析构顺序问题
    std::unique_ptr<router<TestHandler>> router_;
    std::shared_ptr<TestHandler> handler_;
    std::map<std::string, std::string> params_;
    std::map<std::string, std::string> query_params_;

    void SetUp() override
    {
        router_ = std::make_unique<router<TestHandler>>();
        handler_ = std::make_shared<TestHandler>(1);
        params_.clear();
        query_params_.clear();
    }

    void TearDown() override
    {
        // 先清理缓存，然后手动释放router
        try {
            if (router_) {
                router_->clear_cache();
                router_.reset(); // 手动释放
            }
        } catch (...) {
            // 忽略析构过程中的异常
        }
    }

    // 提供便捷的访问方法
    router<TestHandler> &get_router() { return *router_; }
};

// ============================================================================
// split_path_optimized() 函数测试 - split_path_optimized() Function Tests
// ============================================================================

/**
 * @brief 测试基本路径分割功能 - Test basic path splitting functionality
 */
TEST_F(RouterOptimizationTest, SplitPathOptimized_BasicFunctionality)
{
    std::vector<std::string> segments;

    // 测试根路径 - Test root path
    router_->split_path_optimized("/", segments);
    EXPECT_TRUE(segments.empty());

    // 测试空路径 - Test empty path
    router_->split_path_optimized("", segments);
    EXPECT_TRUE(segments.empty());

    // 测试简单路径 - Test simple path
    router_->split_path_optimized("/api", segments);
    ASSERT_EQ(segments.size(), 1);
    EXPECT_EQ(segments[0], "api");

    // 测试多段路径 - Test multi-segment path
    router_->split_path_optimized("/api/v1/users", segments);
    ASSERT_EQ(segments.size(), 3);
    EXPECT_EQ(segments[0], "api");
    EXPECT_EQ(segments[1], "v1");
    EXPECT_EQ(segments[2], "users");
}

/**
 * @brief 测试路径分割的边界条件 - Test edge cases for path splitting
 */
TEST_F(RouterOptimizationTest, SplitPathOptimized_EdgeCases)
{
    std::vector<std::string> segments;

    // 测试连续斜杠 - Test consecutive slashes
    router_->split_path_optimized("/api//v1///users", segments);
    ASSERT_EQ(segments.size(), 3);
    EXPECT_EQ(segments[0], "api");
    EXPECT_EQ(segments[1], "v1");
    EXPECT_EQ(segments[2], "users");

    // 测试尾部斜杠 - Test trailing slash
    router_->split_path_optimized("/api/v1/users/", segments);
    ASSERT_EQ(segments.size(), 3);
    EXPECT_EQ(segments[0], "api");
    EXPECT_EQ(segments[1], "v1");
    EXPECT_EQ(segments[2], "users");

    // 测试没有前导斜杠的路径 - Test path without leading slash
    router_->split_path_optimized("api/v1/users", segments);
    ASSERT_EQ(segments.size(), 3);
    EXPECT_EQ(segments[0], "api");
    EXPECT_EQ(segments[1], "v1");
    EXPECT_EQ(segments[2], "users");

    // 测试只有斜杠的路径 - Test path with only slashes
    router_->split_path_optimized("///", segments);
    EXPECT_TRUE(segments.empty());
}

/**
 * @brief 测试路径分割性能 - Test path splitting performance
 */
TEST_F(RouterOptimizationTest, SplitPathOptimized_Performance)
{
    std::vector<std::string> segments;
    const std::string test_path = "/api/v1/users/12345/profile/settings/notifications";
    const int iterations = 10000;

    // 测试优化版本性能 - Test optimized version performance
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        router_.split_path_optimized(test_path, segments);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto optimized_duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    // 验证结果正确性 - Verify result correctness
    ASSERT_EQ(segments.size(), 7);
    EXPECT_EQ(segments[0], "api");
    EXPECT_EQ(segments[6], "notifications");

    std::cout << "Split path optimized performance: "
              << optimized_duration.count() / static_cast<double>(iterations) << " μs per operation"
              << std::endl;

    // 性能应该合理（每次操作少于10微秒）- Performance should be reasonable (less than 10μs per
    // operation)
    EXPECT_LT(optimized_duration.count() / static_cast<double>(iterations), 10.0);
}

// ============================================================================
// url_decode_safe() 函数测试 - url_decode_safe() Function Tests
// ============================================================================

/**
 * @brief 测试基本URL解码功能 - Test basic URL decoding functionality
 */
TEST_F(RouterOptimizationTest, UrlDecodeSafe_BasicFunctionality)
{
    std::string test_str;

    // 测试加号转空格 - Test plus to space conversion
    test_str = "hello+world";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello world");

    // 测试百分号编码 - Test percent encoding
    test_str = "hello%20world";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello world");

    // 测试混合编码 - Test mixed encoding
    test_str = "hello+%20world%21";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello  world!");

    // 测试大小写十六进制 - Test uppercase and lowercase hex
    test_str = "%41%42%43%61%62%63"; // ABCabc
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "ABCabc");
}

/**
 * @brief 测试URL解码的边界检查 - Test boundary checking for URL decoding
 */
TEST_F(RouterOptimizationTest, UrlDecodeSafe_BoundaryChecking)
{
    std::string test_str;

    // 测试不完整的百分号编码（边界检查修复）- Test incomplete percent encoding (boundary check fix)
    test_str = "hello%2";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello%2"); // 应该保持原样 - Should remain unchanged

    test_str = "hello%";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello%"); // 应该保持原样 - Should remain unchanged

    // 测试字符串末尾的百分号编码 - Test percent encoding at end of string
    test_str = "hello%20%";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello %");

    // 测试无效的十六进制字符 - Test invalid hex characters
    test_str = "hello%XY";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello%XY"); // 应该保持原样 - Should remain unchanged

    test_str = "hello%2G";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello%2G"); // 应该保持原样 - Should remain unchanged
}

/**
 * @brief 测试URL解码的特殊字符 - Test special characters in URL decoding
 */
TEST_F(RouterOptimizationTest, UrlDecodeSafe_SpecialCharacters)
{
    std::string test_str;

    // 测试中文字符的UTF-8编码 - Test UTF-8 encoding for Chinese characters
    test_str = "%E4%B8%AD%E6%96%87"; // 中文
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "中文");

    // 测试特殊符号 - Test special symbols
    test_str = "%21%40%23%24%25%5E%26%2A"; // !@#$%^&*
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "!@#$%^&*");

    // 测试空字符串 - Test empty string
    test_str = "";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "");

    // 测试只有普通字符 - Test only normal characters
    test_str = "hello_world-123";
    router_.url_decode_safe(test_str);
    EXPECT_EQ(test_str, "hello_world-123");
}

/**
 * @brief 测试URL解码性能 - Test URL decoding performance
 */
TEST_F(RouterOptimizationTest, UrlDecodeSafe_Performance)
{
    const std::string encoded_str = "hello%20world%21%40%23%24%25+test%2Bstring";
    const int iterations = 10000;

    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        std::string test_str = encoded_str;
        router_.url_decode_safe(test_str);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    std::cout << "URL decode safe performance: "
              << duration.count() / static_cast<double>(iterations) << " μs per operation"
              << std::endl;

    // 性能应该合理（每次操作少于5微秒）- Performance should be reasonable (less than 5μs per
    // operation)
    EXPECT_LT(duration.count() / static_cast<double>(iterations), 5.0);
}

// ============================================================================
// hex_to_int_safe() 函数测试 - hex_to_int_safe() Function Tests
// ============================================================================

/**
 * @brief 测试十六进制转换基本功能 - Test basic hex conversion functionality
 */
TEST_F(RouterOptimizationTest, HexToIntSafe_BasicFunctionality)
{
    int value;

    // 测试数字字符 - Test digit characters
    EXPECT_TRUE(router_.hex_to_int_safe('0', value));
    EXPECT_EQ(value, 0);
    EXPECT_TRUE(router_.hex_to_int_safe('9', value));
    EXPECT_EQ(value, 9);

    // 测试大写字母 - Test uppercase letters
    EXPECT_TRUE(router_.hex_to_int_safe('A', value));
    EXPECT_EQ(value, 10);
    EXPECT_TRUE(router_.hex_to_int_safe('F', value));
    EXPECT_EQ(value, 15);

    // 测试小写字母 - Test lowercase letters
    EXPECT_TRUE(router_.hex_to_int_safe('a', value));
    EXPECT_EQ(value, 10);
    EXPECT_TRUE(router_.hex_to_int_safe('f', value));
    EXPECT_EQ(value, 15);

    // 测试无效字符 - Test invalid characters
    EXPECT_FALSE(router_.hex_to_int_safe('G', value));
    EXPECT_FALSE(router_.hex_to_int_safe('g', value));
    EXPECT_FALSE(router_.hex_to_int_safe('@', value));
    EXPECT_FALSE(router_.hex_to_int_safe(' ', value));
}

/**
 * @brief 测试十六进制转换性能 - Test hex conversion performance
 */
TEST_F(RouterOptimizationTest, HexToIntSafe_Performance)
{
    const char hex_chars[] = "0123456789ABCDEFabcdef";
    const int iterations = 100000;
    int value;

    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        char c = hex_chars[i % sizeof(hex_chars)];
        router_.hex_to_int_safe(c, value);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

    std::cout << "Hex to int safe performance: "
              << duration.count() / static_cast<double>(iterations) << " ns per operation"
              << std::endl;

    // 性能应该非常快（每次操作少于100纳秒）- Performance should be very fast (less than 100ns per
    // operation)
    EXPECT_LT(duration.count() / static_cast<double>(iterations), 100.0);
}

// ============================================================================
// cache_key_builder 类测试 - cache_key_builder Class Tests
// ============================================================================

/**
 * @brief 测试缓存键构建器基本功能 - Test cache key builder basic functionality
 */
TEST_F(RouterOptimizationTest, CacheKeyBuilder_BasicFunctionality)
{
    auto &builder = router_.get_thread_local_cache_key_builder();

    // 测试基本键构建 - Test basic key building
    const std::string &key1 = builder.build(HttpMethod::GET, "/api/users");
    EXPECT_EQ(key1, "GET:/api/users");

    const std::string &key2 = builder.build(HttpMethod::POST, "/api/users/123");
    EXPECT_EQ(key2, "POST:/api/users/123");

    // 测试缓冲区重用 - Test buffer reuse
    const std::string &key3 = builder.build(HttpMethod::DELETE, "/api");
    EXPECT_EQ(key3, "DELETE:/api");

    // 验证缓冲区容量 - Verify buffer capacity
    EXPECT_GE(builder.capacity(), 128);
}

/**
 * @brief 测试缓存键构建器不同HTTP方法 - Test cache key builder with different HTTP methods
 */
TEST_F(RouterOptimizationTest, CacheKeyBuilder_DifferentMethods)
{
    auto &builder = router_.get_thread_local_cache_key_builder();

    // 测试所有HTTP方法 - Test all HTTP methods
    EXPECT_EQ(builder.build(HttpMethod::GET, "/test"), "GET:/test");
    EXPECT_EQ(builder.build(HttpMethod::POST, "/test"), "POST:/test");
    EXPECT_EQ(builder.build(HttpMethod::PUT, "/test"), "PUT:/test");
    EXPECT_EQ(builder.build(HttpMethod::DELETE, "/test"), "DELETE:/test");
    EXPECT_EQ(builder.build(HttpMethod::PATCH, "/test"), "PATCH:/test");
    EXPECT_EQ(builder.build(HttpMethod::HEAD, "/test"), "HEAD:/test");
    EXPECT_EQ(builder.build(HttpMethod::OPTIONS, "/test"), "OPTIONS:/test");
    EXPECT_EQ(builder.build(HttpMethod::CONNECT, "/test"), "CONNECT:/test");
    EXPECT_EQ(builder.build(HttpMethod::TRACE, "/test"), "TRACE:/test");
    EXPECT_EQ(builder.build(HttpMethod::UNKNOWN, "/test"), "UNKNOWN:/test");
}

/**
 * @brief 测试缓存键构建器性能 - Test cache key builder performance
 */
TEST_F(RouterOptimizationTest, CacheKeyBuilder_Performance)
{
    auto &builder = router_.get_thread_local_cache_key_builder();
    const std::string path = "/api/v1/users/12345/profile";
    const int iterations = 50000;

    // 测试优化版本性能 - Test optimized version performance
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        const std::string &key = builder.build(HttpMethod::GET, path);
        (void)key; // 避免编译器优化掉 - Avoid compiler optimization
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto optimized_duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

    // 测试传统方式性能 - Test traditional approach performance
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        std::string key = to_string(HttpMethod::GET) + ":" + path;
        (void)key; // 避免编译器优化掉 - Avoid compiler optimization
    }
    end = std::chrono::high_resolution_clock::now();
    auto traditional_duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

    std::cout << "Cache key builder performance: "
              << optimized_duration.count() / static_cast<double>(iterations) << " ns per operation"
              << std::endl;
    std::cout << "Traditional approach performance: "
              << traditional_duration.count() / static_cast<double>(iterations)
              << " ns per operation" << std::endl;

    // 优化版本应该比传统方式快 - Optimized version should be faster than traditional approach
    EXPECT_LT(optimized_duration.count(), traditional_duration.count());

    // 计算性能提升比例 - Calculate performance improvement ratio
    double improvement_ratio =
        static_cast<double>(traditional_duration.count()) / optimized_duration.count();
    std::cout << "Performance improvement: " << improvement_ratio << "x faster" << std::endl;

    // 应该至少有20%的性能提升 - Should have at least 20% performance improvement
    EXPECT_GT(improvement_ratio, 1.2);
}

/**
 * @brief 测试缓存键构建器重置功能 - Test cache key builder reset functionality
 */
TEST_F(RouterOptimizationTest, CacheKeyBuilder_Reset)
{
    auto &builder = router_.get_thread_local_cache_key_builder();

    // 构建一些键 - Build some keys
    builder.build(HttpMethod::GET, "/api/users");
    size_t original_capacity = builder.capacity();

    // 重置不改变容量 - Reset without changing capacity
    builder.reset();
    EXPECT_EQ(builder.capacity(), original_capacity);

    // 重置并改变容量 - Reset and change capacity
    builder.reset(256);
    EXPECT_GE(builder.capacity(), 256);

    // 验证重置后仍能正常工作 - Verify it still works after reset
    const std::string &key = builder.build(HttpMethod::POST, "/test");
    EXPECT_EQ(key, "POST:/test");
}

// ============================================================================
// 集成测试 - Integration Tests
// ============================================================================

/**
 * @brief 测试优化功能的集成效果 - Test integration effect of optimization features
 */
TEST_F(RouterOptimizationTest, Integration_FullRouterOptimization)
{
    // 添加各种类型的路由 - Add various types of routes
    auto static_handler = std::make_shared<TestHandler>(1);
    auto param_handler = std::make_shared<TestHandler>(2);
    auto wildcard_handler = std::make_shared<TestHandler>(3);

    router_.add_route(HttpMethod::GET, "/api/static", static_handler);
    router_.add_route(HttpMethod::GET, "/api/users/:id", param_handler);
    router_.add_route(HttpMethod::GET, "/api/files/*", wildcard_handler);

    std::shared_ptr<TestHandler> found_handler;

    // 测试静态路由查找 - Test static route lookup
    EXPECT_EQ(0, router_.find_route(HttpMethod::GET, "/api/static", found_handler, params_,
                                    query_params_));
    EXPECT_EQ(found_handler->id(), 1);

    // 测试参数化路由查找 - Test parameterized route lookup
    EXPECT_EQ(0, router_.find_route(HttpMethod::GET, "/api/users/123", found_handler, params_,
                                    query_params_));
    EXPECT_EQ(found_handler->id(), 2);
    EXPECT_EQ(params_["id"], "123");

    // 测试通配符路由查找 - Test wildcard route lookup
    EXPECT_EQ(0, router_.find_route(HttpMethod::GET, "/api/files/docs/readme.txt", found_handler,
                                    params_, query_params_));
    EXPECT_EQ(found_handler->id(), 3);
    EXPECT_EQ(params_["*"], "docs/readme.txt");

    // 测试带查询参数的路由 - Test route with query parameters
    EXPECT_EQ(0, router_.find_route(HttpMethod::GET, "/api/users/456?name=john&age=25",
                                    found_handler, params_, query_params_));
    EXPECT_EQ(found_handler->id(), 2);
    EXPECT_EQ(params_["id"], "456");
    EXPECT_EQ(query_params_["name"], "john");
    EXPECT_EQ(query_params_["age"], "25");

    // 测试URL编码的查询参数 - Test URL encoded query parameters
    EXPECT_EQ(0, router_.find_route(HttpMethod::GET,
                                    "/api/users/789?message=hello%20world&encoded=%21%40%23",
                                    found_handler, params_, query_params_));
    EXPECT_EQ(found_handler->id(), 2);
    EXPECT_EQ(params_["id"], "789");
    EXPECT_EQ(query_params_["message"], "hello world");
    EXPECT_EQ(query_params_["encoded"], "!@#");
}

/**
 * @brief 性能基准测试 - Performance benchmark test
 */
TEST_F(RouterOptimizationTest, Integration_PerformanceBenchmark)
{
    // 添加大量路由以模拟真实场景 - Add many routes to simulate real scenario
    const int num_routes = 1000;
    for (int i = 0; i < num_routes; ++i) {
        auto handler = std::make_shared<TestHandler>(i);
        router_.add_route(HttpMethod::GET, "/api/route" + std::to_string(i), handler);
        router_.add_route(HttpMethod::GET, "/api/users/:id/action" + std::to_string(i), handler);
        router_.add_route(HttpMethod::GET, "/api/files" + std::to_string(i) + "/*", handler);
    }

    const int lookup_iterations = 1000;
    std::shared_ptr<TestHandler> found_handler;

    // 测试静态路由查找性能 - Test static route lookup performance
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < lookup_iterations; ++i) {
        router_.find_route(HttpMethod::GET, "/api/route500", found_handler, params_, query_params_);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto static_duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    // 测试参数化路由查找性能 - Test parameterized route lookup performance
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < lookup_iterations; ++i) {
        router_.find_route(HttpMethod::GET, "/api/users/12345/action500", found_handler, params_,
                           query_params_);
    }
    end = std::chrono::high_resolution_clock::now();
    auto param_duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    // 测试通配符路由查找性能 - Test wildcard route lookup performance
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < lookup_iterations; ++i) {
        router_.find_route(HttpMethod::GET, "/api/files500/docs/readme.txt", found_handler, params_,
                           query_params_);
    }
    end = std::chrono::high_resolution_clock::now();
    auto wildcard_duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    std::cout << "Performance benchmark with " << num_routes << " routes:" << std::endl;
    std::cout << "Static route lookup: "
              << static_duration.count() / static_cast<double>(lookup_iterations)
              << " μs per lookup" << std::endl;
    std::cout << "Parameterized route lookup: "
              << param_duration.count() / static_cast<double>(lookup_iterations) << " μs per lookup"
              << std::endl;
    std::cout << "Wildcard route lookup: "
              << wildcard_duration.count() / static_cast<double>(lookup_iterations)
              << " μs per lookup" << std::endl;

    // 性能要求验证 - Performance requirement verification
    EXPECT_LT(static_duration.count() / static_cast<double>(lookup_iterations), 1.0);    // < 1μs
    EXPECT_LT(param_duration.count() / static_cast<double>(lookup_iterations), 15.0);    // < 15μs
    EXPECT_LT(wildcard_duration.count() / static_cast<double>(lookup_iterations), 20.0); // < 20μs
}

// ============================================================================
// 线程安全测试 - Thread Safety Tests
// ============================================================================

/**
 * @brief 测试多线程环境下的线程安全性 - Test thread safety in multi-threaded environment
 */
TEST_F(RouterOptimizationTest, ThreadSafety_ConcurrentAccess)
{
    // 添加一些路由 - Add some routes
    for (int i = 0; i < 10; ++i) {
        auto handler = std::make_shared<TestHandler>(i);
        router_.add_route(HttpMethod::GET, "/api/test" + std::to_string(i), handler);
    }

    const int num_threads = 8;
    const int operations_per_thread = 1000;
    std::vector<std::thread> threads;
    std::atomic<int> success_count{0};

    // 创建多个线程同时进行路由查找 - Create multiple threads for concurrent route lookup
    for (int t = 0; t < num_threads; ++t) {
        threads.emplace_back([&, t]() {
            std::shared_ptr<TestHandler> found_handler;
            std::map<std::string, std::string> local_params;
            std::map<std::string, std::string> local_query_params;

            for (int i = 0; i < operations_per_thread; ++i) {
                std::string path = "/api/test" + std::to_string(i % 10);
                if (router_.find_route(HttpMethod::GET, path, found_handler, local_params,
                                       local_query_params) == 0) {
                    success_count++;
                }
            }
        });
    }

    // 等待所有线程完成 - Wait for all threads to complete
    for (auto &thread : threads) {
        thread.join();
    }

    // 验证所有操作都成功 - Verify all operations succeeded
    EXPECT_EQ(success_count.load(), num_threads * operations_per_thread);
}

/**
 * @brief 测试线程本地缓存键构建器的线程安全性 - Test thread safety of thread-local cache key
 * builder
 */
TEST_F(RouterOptimizationTest, ThreadSafety_ThreadLocalCacheKeyBuilder)
{
    const int num_threads = 4;
    const int operations_per_thread = 1000;
    std::vector<std::thread> threads;
    std::vector<std::string> results[num_threads];

    // 创建多个线程同时使用缓存键构建器 - Create multiple threads using cache key builder
    // concurrently
    for (int t = 0; t < num_threads; ++t) {
        threads.emplace_back([&, t]() {
            auto &builder = router_.get_thread_local_cache_key_builder();
            results[t].reserve(operations_per_thread);

            for (int i = 0; i < operations_per_thread; ++i) {
                std::string path = "/api/thread" + std::to_string(t) + "/item" + std::to_string(i);
                const std::string &key = builder.build(HttpMethod::GET, path);
                results[t].push_back(key);
            }
        });
    }

    // 等待所有线程完成 - Wait for all threads to complete
    for (auto &thread : threads) {
        thread.join();
    }

    // 验证每个线程的结果都是正确的 - Verify each thread's results are correct
    for (int t = 0; t < num_threads; ++t) {
        EXPECT_EQ(results[t].size(), operations_per_thread);
        for (int i = 0; i < operations_per_thread; ++i) {
            std::string expected =
                "GET:/api/thread" + std::to_string(t) + "/item" + std::to_string(i);
            EXPECT_EQ(results[t][i], expected);
        }
    }
}

// ============================================================================
// 内存安全测试 - Memory Safety Tests
// ============================================================================

/**
 * @brief 测试大数据量处理的内存安全性 - Test memory safety with large data processing
 */
TEST_F(RouterOptimizationTest, MemorySafety_LargeDataProcessing)
{
    // 测试大字符串的URL解码 - Test URL decoding with large strings
    std::string large_encoded;
    large_encoded.reserve(10000);

    // 构建大的编码字符串 - Build large encoded string
    for (int i = 0; i < 1000; ++i) {
        large_encoded += "hello%20world%21+test" + std::to_string(i) + "%2B";
    }

    // 解码不应该崩溃或内存泄漏 - Decoding should not crash or leak memory
    router_.url_decode_safe(large_encoded);
    EXPECT_GT(large_encoded.length(), 5000); // 验证确实被解码了 - Verify it was actually decoded

    // 测试大路径的分割 - Test splitting large paths
    std::string large_path = "/";
    for (int i = 0; i < 100; ++i) {
        large_path += "segment" + std::to_string(i) + "/";
    }

    std::vector<std::string> segments;
    router_.split_path_optimized(large_path, segments);
    EXPECT_EQ(segments.size(), 100);
    EXPECT_EQ(segments[0], "segment0");
    EXPECT_EQ(segments[99], "segment99");
}

/**
 * @brief 测试缓冲区边界安全性 - Test buffer boundary safety
 */
TEST_F(RouterOptimizationTest, MemorySafety_BufferBoundaries)
{
    std::string test_str;

    // 测试边界条件的URL解码 - Test boundary conditions in URL decoding
    std::vector<std::string> edge_cases = {
        "%", "%2", "%G", "%2G", "%GG", "%%", "%20%", "%20%2", "normal%20text%", "text%end"};

    for (const auto &edge_case : edge_cases) {
        test_str = edge_case;
        // 这些都不应该崩溃 - None of these should crash
        EXPECT_NO_THROW(router_.url_decode_safe(test_str));
    }

    // 测试极端路径分割情况 - Test extreme path splitting cases
    std::vector<std::string> path_edge_cases = {
        "", "/", "//", "///", "////", "/a/", "//a//", "///a///", "/a//b//c/", "a", "a/b", "a/b/c"};

    for (const auto &path_case : path_edge_cases) {
        std::vector<std::string> segments;
        // 这些都不应该崩溃 - None of these should crash
        EXPECT_NO_THROW(router_.split_path_optimized(path_case, segments));
    }
}

// ============================================================================
// 回归测试 - Regression Tests
// ============================================================================

/**
 * @brief 确保优化版本与原版本行为一致 - Ensure optimized version behaves consistently with original
 */
TEST_F(RouterOptimizationTest, Regression_BackwardCompatibility)
{
    // 确保优化后的函数与原函数行为完全一致 - Ensure optimized functions behave exactly like
    // original functions

    std::vector<std::string> test_paths = {"/",
                                           "/api",
                                           "/api/v1",
                                           "/api/v1/users",
                                           "/api/v1/users/123",
                                           "api/v1/users",
                                           "/api//v1///users/",
                                           "///api/v1/users///"};

    for (const auto &path : test_paths) {
        std::vector<std::string> optimized_segments, legacy_segments;

        router_.split_path_optimized(path, optimized_segments);
        router_.split_path(path, legacy_segments);

        EXPECT_EQ(optimized_segments.size(), legacy_segments.size())
            << "Size mismatch for path: " << path;

        for (size_t i = 0; i < optimized_segments.size(); ++i) {
            EXPECT_EQ(optimized_segments[i], legacy_segments[i])
                << "Segment mismatch at index " << i << " for path: " << path;
        }
    }

    // 测试URL解码的一致性 - Test URL decoding consistency
    std::vector<std::string> url_test_cases = {"hello+world", "hello%20world", "hello%21world",
                                               "%41%42%43",   "normal_text",   "",
                                               "hello%2",     "hello%",        "hello%XY"};

    for (const auto &test_case : url_test_cases) {
        std::string optimized_str = test_case;
        std::string legacy_str = test_case;

        router_.url_decode_safe(optimized_str);
        router_.url_decode(legacy_str);

        EXPECT_EQ(optimized_str, legacy_str) << "URL decode mismatch for input: " << test_case;
    }
}
